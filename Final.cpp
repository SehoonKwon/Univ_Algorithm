//#include <iostream>
//using namespace std;
//
//int dy[4] = { 0,0,1,-1 }; //상하
//int dx[4] = { -1,1,0,0 }; //좌우
//int visit[17][30] = { 0 };
//
//int A_i, A_j, B_i, B_j;
//
//int N, M;
//
////맵 가로 30 세로 17
////지도 그리기. 길은 1로. 건물은 번지수+1로 표시
//int Map[17][30] = {
//	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },
//	{ 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0 },
//	{ 0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1,0 },
//	{ 0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0 },
//	{ 0,1,3,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,4,0,0,0,0,0,0,0,1,0 },
//	{ 0,1,0,0,0,1,0,0,5,0,0,0,1,0,6,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0 },
//	{ 0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,7,0,0,0,0,0,0,1,0 },
//	{ 0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0 },
//	{ 0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0 },
//	{ 0,1,0,0,0,0,0,0,8,0,0,0,1,0,0,0,0,0,0,0,0,0,0,9,1,0,0,0,1,0 },
//	{ 0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0 },
//	{ 0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,10,0,1,0 },
//	{ 0,1,0,0,0,11,0,0,1,0,0,0,0,0,0,12,0,0,0,0,0,1,1,1,1,1,1,0,1,0 },
//	{ 0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,13,0,0,0,0,0,1,0 },
//	{ 0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0 },
//	{ 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0 },
//	{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }
//};
//
//void DFS(int x,int y, int left, int right)
//{
//	visit[x][y] = true; //방문했다고 표시
////	cout << x << " " << y << endl;;
//
//	for (int k = 0; k < 4; k++)
//	{
//		int nx = x + dx[k], ny = y + dy[k];
//		if(nx < 0 || nx >= 31 || ny < 0 || ny >= 18) continue; //범위를 벗어나면 무시
//		
//		//해당 번지수를 찾으면 좌회전, 우회전 횟수를 출력하고 종료
//		if (!visit[nx][ny] && Map[nx][ny] == M+1)
//		{	
//			//cout << "찾음 " << endl;
//			//cout << ny << " " << nx << endl;
//			cout << left << " " << right;
//			return;
//		}
//		
//		//좌회전, 우회전 하는 경우를 나누어서 카운트
//		else if (!visit[nx][ny] && Map[nx][ny] == 1)
//		{
//			if (k == 0)
//			{
//				if (Map[nx + 1][ny] == 0 && Map[nx][ny + 1] == 0)
//					left++;
//				else if (Map[nx - 1][ny] == 0 && Map[nx][ny + 1] == 0)
//					left++;
//			}
//
//			else if (k == 1)
//			{
//				if (Map[nx + 1][ny] == 0 && Map[nx][ny - 1] == 0)
//					right++;
//				else if (Map[nx - 1][ny] == 0 && Map[nx][ny + 1] == 0)
//					right++;
//			}
//
//			else if (k == 2)
//			{
//				if (Map[nx][ny - 1] == 0 && Map[nx - 1][ny] == 0)
//					right++;
//				else if (Map[nx][ny - 1] == 0 && Map[nx + 1][ny] == 0)
//					left++;
//			}
//			else if (k == 3)
//			{
//				if (Map[nx][ny + 1] == 0 && Map[nx + 1][ny] == 0)
//					right++;
//				else if (Map[nx][ny - 1] == 0 && Map[nx + 1][ny] == 0)
//					left++;
//			}
//			
////			cout << nx << " " << ny << endl;
//			DFS(nx, ny, left, right);
//		}
//
//	}
//}
//
////최소 값
//int minDistance(int dist[], bool sptSet[])
//{
//	int min = INT_MAX, min_index;
//
//	for (int v = 0; v < N; v++)
//		if (sptSet[v] == false && dist[v] <= min)
//			min = dist[v], min_index = v;
//
//	return min_index;
//}
//
////다익스트라
//void dijkstra(int **Map, int src)
//{
//	int *dist = new int[N]();
//
//	bool *sptSet = new bool[N]();
//
//	for (int i = 0; i < N; i++)
//		dist[i] = INT_MAX, sptSet[i] = false;
//
//	dist[src] = 0;
//
//	for (int count = 0; count < N - 1; count++)
//	{
//		int u = minDistance(dist, sptSet);
//
//		sptSet[u] = true;
//
//		for (int v = 0; v < N; v++)
//
//			if (!sptSet[v] && Map[u][v] && dist[u] != INT_MAX
//				&& dist[u] + Map[u][v] < dist[v])
//				dist[v] = dist[u] + Map[u][v];
//	}
//}
//
//int main()
//{
//	//찾고자 하는 번지수 입력
//	cin >> N >> M;
//
//	//번지수를 맵 어느 인덱스인지 찾기
//	for (int i = 0; i < 17; i++)
//		for (int j = 0; j < 30; j++)
//		{
//			if (Map[i][j] == N + 1)
//			{
//				A_i = i;
//				A_j = j;
//			}
//
//			if (Map[i][j] == M + 1)
//			{
//				B_i = i;
//				B_j = j;
//			}
//		}
//
//	////인덱스 확인용
////	cout << "시작 : "<< A_i << " " << A_j << endl;
//	//cout << B_i << " " << B_j << endl;
//
//	int left = 0, right = 0;
//	DFS(A_i, A_j, left, right);
//
//	return 0;
//}